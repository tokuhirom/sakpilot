// Code generated by ogen, DO NOT EDIT.

package apprun

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// CreateApplication invokes createApplication operation.
	//
	// 指定したクラスタに新しいアプリケーションを作成します。1アカウントにつき最大10個まで作成可能です。.
	//
	// POST /applications
	CreateApplication(ctx context.Context, request *CreateApplication) (*CreateApplicationResponse, error)
	// CreateApplicationVersion invokes createApplicationVersion operation.
	//
	// アプリケーションバージョンを作成します｡アプリケーションバージョンを作成するだけではノードにデプロイされません｡アプリケーションのアクティブバージョンに指定するとノードにデプロイされます｡.
	//
	// POST /applications/{applicationID}/versions
	CreateApplicationVersion(ctx context.Context, request *CreateApplicationVersion, params CreateApplicationVersionParams) (*CreateApplicationVersionResponse, error)
	// CreateAutoScalingGroup invokes createAutoScalingGroup operation.
	//
	// 新しい Auto Scaling Group を作成します。.
	//
	// POST /clusters/{clusterID}/asg
	CreateAutoScalingGroup(ctx context.Context, request *CreateAutoScalingGroup, params CreateAutoScalingGroupParams) (*CreateAutoScalingGroupResponse, error)
	// CreateCertificate invokes createCertificate operation.
	//
	// 新しい証明書を作成します。.
	//
	// POST /clusters/{clusterID}/certificates
	CreateCertificate(ctx context.Context, request *CreateCertificate, params CreateCertificateParams) (*CreateCertificateResponse, error)
	// CreateCluster invokes createCluster operation.
	//
	// 新しいクラスタを作成します。作成後にクラスタIDを返します。.
	//
	// POST /clusters
	CreateCluster(ctx context.Context, request *CreateCluster) (*CreateClusterResponse, error)
	// CreateLoadBalancer invokes createLoadBalancer operation.
	//
	// 指定したAuto Scaling Groupにロードバランサーを作成します。.
	//
	// POST /clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers
	CreateLoadBalancer(ctx context.Context, request *CreateLoadBalancer, params CreateLoadBalancerParams) (*CreateLoadBalancerResponse, error)
	// DeleteApplication invokes deleteApplication operation.
	//
	// 指定したアプリケーションを削除します。
	// ## 前提条件
	// - 当該アプリケーションに **アクティブなバージョンが存在しない** こと
	// - いずれのワーカーノードでも当該アプリケーションの
	// **コンテナが稼働していない** こと.
	//
	// DELETE /applications/{applicationID}
	DeleteApplication(ctx context.Context, params DeleteApplicationParams) error
	// DeleteApplicationVersion invokes deleteApplicationVersion operation.
	//
	// 現在ノードにデプロイされているバージョンおよびアクティブなバージョンは削除出来ない｡.
	//
	// DELETE /applications/{applicationID}/versions/{version}
	DeleteApplicationVersion(ctx context.Context, params DeleteApplicationVersionParams) error
	// DeleteAutoScalingGroup invokes deleteAutoScalingGroup operation.
	//
	// 指定した Auto Scaling Group を削除します。.
	//
	// DELETE /clusters/{clusterID}/asg/{autoScalingGroupID}
	DeleteAutoScalingGroup(ctx context.Context, params DeleteAutoScalingGroupParams) error
	// DeleteCertificate invokes deleteCertificate operation.
	//
	// 指定した証明書を削除します。.
	//
	// DELETE /clusters/{clusterID}/certificates/{certificateID}
	DeleteCertificate(ctx context.Context, params DeleteCertificateParams) error
	// DeleteCluster invokes deleteCluster operation.
	//
	// 指定したクラスタを削除します。.
	//
	// DELETE /clusters/{clusterID}
	DeleteCluster(ctx context.Context, params DeleteClusterParams) error
	// DeleteLoadBalancer invokes deleteLoadBalancer operation.
	//
	// 指定したロードバランサーを削除します。.
	//
	// DELETE /clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers/{loadBalancerID}
	DeleteLoadBalancer(ctx context.Context, params DeleteLoadBalancerParams) error
	// GetApplication invokes getApplication operation.
	//
	// 指定したアプリケーションIDの詳細情報を返します。.
	//
	// GET /applications/{applicationID}
	GetApplication(ctx context.Context, params GetApplicationParams) (*GetApplicationResponse, error)
	// GetApplicationContainers invokes getApplicationContainers operation.
	//
	// 指定したアプリケーションの各ワーカーノード上でのコンテナ配置情報を返します。.
	//
	// GET /applications/{applicationID}/containers
	GetApplicationContainers(ctx context.Context, params GetApplicationContainersParams) (*GetApplicationContainersResponse, error)
	// GetApplicationVersion invokes getApplicationVersion operation.
	//
	// 指定されたバージョンの詳細取得.
	//
	// GET /applications/{applicationID}/versions/{version}
	GetApplicationVersion(ctx context.Context, params GetApplicationVersionParams) (*GetApplicationVersionResponse, error)
	// GetAutoScalingGroup invokes getAutoScalingGroup operation.
	//
	// 指定した Auto Scaling Group の詳細情報を返します。.
	//
	// GET /clusters/{clusterID}/asg/{autoScalingGroupID}
	GetAutoScalingGroup(ctx context.Context, params GetAutoScalingGroupParams) (*GetAutoScalingGroupResponse, error)
	// GetCertificate invokes getCertificate operation.
	//
	// 指定した証明書の詳細情報を返します。.
	//
	// GET /clusters/{clusterID}/certificates/{certificateID}
	GetCertificate(ctx context.Context, params GetCertificateParams) (*GetCertificateResponse, error)
	// GetCluster invokes getCluster operation.
	//
	// 指定したクラスタの詳細情報を返します。.
	//
	// GET /clusters/{clusterID}
	GetCluster(ctx context.Context, params GetClusterParams) (*GetClusterResponse, error)
	// GetLoadBalancer invokes getLoadBalancer operation.
	//
	// 指定したロードバランサーの詳細情報を返します。.
	//
	// GET /clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers/{loadBalancerID}
	GetLoadBalancer(ctx context.Context, params GetLoadBalancerParams) (*GetLoadBalancerResponse, error)
	// GetLoadBalancerNode invokes getLoadBalancerNode operation.
	//
	// 指定したロードバランサーノードの詳細情報を返します。.
	//
	// GET /clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers/{loadBalancerID}/load_balancer_nodes/{loadBalancerNodeID}
	GetLoadBalancerNode(ctx context.Context, params GetLoadBalancerNodeParams) (*GetLoadBalancerNodeResponse, error)
	// GetWorkerNode invokes getWorkerNode operation.
	//
	// 指定したワーカーノードの詳細情報を返します。.
	//
	// GET /clusters/{clusterID}/asg/{autoScalingGroupID}/worker_nodes/{workerNodeID}
	GetWorkerNode(ctx context.Context, params GetWorkerNodeParams) (*GetWorkerNodeResponse, error)
	// ListApplicationVersions invokes listApplicationVersions operation.
	//
	// 指定されたアプリケーションのバージョン一覧取得.
	//
	// GET /applications/{applicationID}/versions
	ListApplicationVersions(ctx context.Context, params ListApplicationVersionsParams) (*ListApplicationVersionResponse, error)
	// ListApplications invokes listApplications operation.
	//
	// 指定したアカウントに紐づくアプリケーションの一覧を返します。.
	//
	// GET /applications
	ListApplications(ctx context.Context, params ListApplicationsParams) (*ListApplicationResponse, error)
	// ListAutoScalingGroups invokes listAutoScalingGroups operation.
	//
	// クラスタに所属する Auto Scaling Group
	// の一覧を返します。ページネーションに対応します。.
	//
	// GET /clusters/{clusterID}/asg
	ListAutoScalingGroups(ctx context.Context, params ListAutoScalingGroupsParams) (*ListAutoScalingGroupResponse, error)
	// ListCertificate invokes listCertificate operation.
	//
	// クラスタ内の証明書一覧を返します。ページネーションに対応します。.
	//
	// GET /clusters/{clusterID}/certificates
	ListCertificate(ctx context.Context, params ListCertificateParams) (*ListCertificateResponse, error)
	// ListClusters invokes listClusters operation.
	//
	// アカウントに紐づくクラスタの一覧を返します。ページネーションに対応します。.
	//
	// GET /clusters
	ListClusters(ctx context.Context, params ListClustersParams) (*ListClusterResponse, error)
	// ListLbServiceClasses invokes listLbServiceClasses operation.
	//
	// ロードバランサ用のサービスクラス一覧を返します。.
	//
	// GET /service_classes/lb
	ListLbServiceClasses(ctx context.Context) (*ListLbServiceClassResponse, error)
	// ListLoadBalancerNodes invokes listLoadBalancerNodes operation.
	//
	// 指定したロードバランサーに属するノードの一覧を返します。.
	//
	// GET /clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers/{loadBalancerID}/load_balancer_nodes
	ListLoadBalancerNodes(ctx context.Context, params ListLoadBalancerNodesParams) (*ListLoadBalancerNodesResponse, error)
	// ListLoadBalancers invokes listLoadBalancers operation.
	//
	// Auto Scaling Group
	// に属するロードバランサーの一覧を返します。ページネーションに対応します。.
	//
	// GET /clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers
	ListLoadBalancers(ctx context.Context, params ListLoadBalancersParams) (*ListLoadBalancersResponse, error)
	// ListWorkerNodes invokes listWorkerNodes operation.
	//
	// Auto Scaling Group
	// に所属するワーカーノードの一覧を返します。ページネーションに対応します。.
	//
	// GET /clusters/{clusterID}/asg/{autoScalingGroupID}/worker_nodes
	ListWorkerNodes(ctx context.Context, params ListWorkerNodesParams) (*ListWorkerNodesResponse, error)
	// ListWorkerServiceClasses invokes listWorkerServiceClasses operation.
	//
	// ワーカーノード用のサービスクラス一覧を返します。.
	//
	// GET /service_classes/worker
	ListWorkerServiceClasses(ctx context.Context) (*ListWorkerServiceClassResponse, error)
	// UpdateApplication invokes updateApplication operation.
	//
	// アプリケーションのactiveVersionなどを更新します。クラスタの変更はできません。activeVersionを変更すると指定したバージョンがデプロイされます。activeVersionをnullにするとアプリケーションは非アクティブ状態になり､デプロイされなくなります。アプリケーション削除前には activeVersion を null にする必要があります｡.
	//
	// PUT /applications/{applicationID}
	UpdateApplication(ctx context.Context, request *UpdateApplication, params UpdateApplicationParams) error
	// UpdateCertificate invokes updateCertificate operation.
	//
	// 指定した証明書を更新します。.
	//
	// PUT /clusters/{clusterID}/certificates/{certificateID}
	UpdateCertificate(ctx context.Context, request *UpdateCertificate, params UpdateCertificateParams) error
	// UpdateCluster invokes updateCluster operation.
	//
	// 指定したクラスタの設定を更新します。.
	//
	// PUT /clusters/{clusterID}
	UpdateCluster(ctx context.Context, request *UpdateCluster, params UpdateClusterParams) error
	// UpdateWorkerNodeDrainingState invokes updateWorkerNodeDrainingState operation.
	//
	// 指定したワーカーノードのdraining状態を更新します（draining
	// を有効/無効にします）。.
	//
	// PUT /clusters/{clusterID}/asg/{autoScalingGroupID}/worker_nodes/{workerNodeID}/draining
	UpdateWorkerNodeDrainingState(ctx context.Context, request *UpdateWorkerNodeDrainingRequest, params UpdateWorkerNodeDrainingStateParams) error
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}
type errorHandler interface {
	NewError(ctx context.Context, err error) *ErrorStatusCode
}

var _ Handler = struct {
	errorHandler
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// CreateApplication invokes createApplication operation.
//
// 指定したクラスタに新しいアプリケーションを作成します。1アカウントにつき最大10個まで作成可能です。.
//
// POST /applications
func (c *Client) CreateApplication(ctx context.Context, request *CreateApplication) (*CreateApplicationResponse, error) {
	res, err := c.sendCreateApplication(ctx, request)
	return res, err
}

func (c *Client) sendCreateApplication(ctx context.Context, request *CreateApplication) (res *CreateApplicationResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createApplication"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/applications"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateApplicationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/applications"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateApplicationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, CreateApplicationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateApplicationVersion invokes createApplicationVersion operation.
//
// アプリケーションバージョンを作成します｡アプリケーションバージョンを作成するだけではノードにデプロイされません｡アプリケーションのアクティブバージョンに指定するとノードにデプロイされます｡.
//
// POST /applications/{applicationID}/versions
func (c *Client) CreateApplicationVersion(ctx context.Context, request *CreateApplicationVersion, params CreateApplicationVersionParams) (*CreateApplicationVersionResponse, error) {
	res, err := c.sendCreateApplicationVersion(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateApplicationVersion(ctx context.Context, request *CreateApplicationVersion, params CreateApplicationVersionParams) (res *CreateApplicationVersionResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createApplicationVersion"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/applications/{applicationID}/versions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateApplicationVersionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/applications/"
	{
		// Encode "applicationID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "applicationID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ApplicationID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateApplicationVersionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, CreateApplicationVersionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateApplicationVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAutoScalingGroup invokes createAutoScalingGroup operation.
//
// 新しい Auto Scaling Group を作成します。.
//
// POST /clusters/{clusterID}/asg
func (c *Client) CreateAutoScalingGroup(ctx context.Context, request *CreateAutoScalingGroup, params CreateAutoScalingGroupParams) (*CreateAutoScalingGroupResponse, error) {
	res, err := c.sendCreateAutoScalingGroup(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateAutoScalingGroup(ctx context.Context, request *CreateAutoScalingGroup, params CreateAutoScalingGroupParams) (res *CreateAutoScalingGroupResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createAutoScalingGroup"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/asg"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateAutoScalingGroupOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/asg"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAutoScalingGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, CreateAutoScalingGroupOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAutoScalingGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCertificate invokes createCertificate operation.
//
// 新しい証明書を作成します。.
//
// POST /clusters/{clusterID}/certificates
func (c *Client) CreateCertificate(ctx context.Context, request *CreateCertificate, params CreateCertificateParams) (*CreateCertificateResponse, error) {
	res, err := c.sendCreateCertificate(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateCertificate(ctx context.Context, request *CreateCertificate, params CreateCertificateParams) (res *CreateCertificateResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createCertificate"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/certificates"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateCertificateOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/certificates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCertificateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, CreateCertificateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateCertificateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCluster invokes createCluster operation.
//
// 新しいクラスタを作成します。作成後にクラスタIDを返します。.
//
// POST /clusters
func (c *Client) CreateCluster(ctx context.Context, request *CreateCluster) (*CreateClusterResponse, error) {
	res, err := c.sendCreateCluster(ctx, request)
	return res, err
}

func (c *Client) sendCreateCluster(ctx context.Context, request *CreateCluster) (res *CreateClusterResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createCluster"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/clusters"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateClusterOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/clusters"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateClusterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, CreateClusterOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateLoadBalancer invokes createLoadBalancer operation.
//
// 指定したAuto Scaling Groupにロードバランサーを作成します。.
//
// POST /clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers
func (c *Client) CreateLoadBalancer(ctx context.Context, request *CreateLoadBalancer, params CreateLoadBalancerParams) (*CreateLoadBalancerResponse, error) {
	res, err := c.sendCreateLoadBalancer(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateLoadBalancer(ctx context.Context, request *CreateLoadBalancer, params CreateLoadBalancerParams) (res *CreateLoadBalancerResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createLoadBalancer"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateLoadBalancerOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/asg/"
	{
		// Encode "autoScalingGroupID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoScalingGroupID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.AutoScalingGroupID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/load_balancers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateLoadBalancerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, CreateLoadBalancerOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateLoadBalancerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteApplication invokes deleteApplication operation.
//
// 指定したアプリケーションを削除します。
// ## 前提条件
// - 当該アプリケーションに **アクティブなバージョンが存在しない** こと
// - いずれのワーカーノードでも当該アプリケーションの
// **コンテナが稼働していない** こと.
//
// DELETE /applications/{applicationID}
func (c *Client) DeleteApplication(ctx context.Context, params DeleteApplicationParams) error {
	_, err := c.sendDeleteApplication(ctx, params)
	return err
}

func (c *Client) sendDeleteApplication(ctx context.Context, params DeleteApplicationParams) (res *DeleteApplicationNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteApplication"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/applications/{applicationID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteApplicationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/applications/"
	{
		// Encode "applicationID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "applicationID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ApplicationID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, DeleteApplicationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteApplicationVersion invokes deleteApplicationVersion operation.
//
// 現在ノードにデプロイされているバージョンおよびアクティブなバージョンは削除出来ない｡.
//
// DELETE /applications/{applicationID}/versions/{version}
func (c *Client) DeleteApplicationVersion(ctx context.Context, params DeleteApplicationVersionParams) error {
	_, err := c.sendDeleteApplicationVersion(ctx, params)
	return err
}

func (c *Client) sendDeleteApplicationVersion(ctx context.Context, params DeleteApplicationVersionParams) (res *DeleteApplicationVersionNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteApplicationVersion"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/applications/{applicationID}/versions/{version}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteApplicationVersionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/applications/"
	{
		// Encode "applicationID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "applicationID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ApplicationID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions/"
	{
		// Encode "version" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "version",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := int32(params.Version); true {
				return e.EncodeValue(conv.Int32ToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, DeleteApplicationVersionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteApplicationVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAutoScalingGroup invokes deleteAutoScalingGroup operation.
//
// 指定した Auto Scaling Group を削除します。.
//
// DELETE /clusters/{clusterID}/asg/{autoScalingGroupID}
func (c *Client) DeleteAutoScalingGroup(ctx context.Context, params DeleteAutoScalingGroupParams) error {
	_, err := c.sendDeleteAutoScalingGroup(ctx, params)
	return err
}

func (c *Client) sendDeleteAutoScalingGroup(ctx context.Context, params DeleteAutoScalingGroupParams) (res *DeleteAutoScalingGroupNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteAutoScalingGroup"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/asg/{autoScalingGroupID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteAutoScalingGroupOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/asg/"
	{
		// Encode "autoScalingGroupID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoScalingGroupID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.AutoScalingGroupID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, DeleteAutoScalingGroupOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAutoScalingGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCertificate invokes deleteCertificate operation.
//
// 指定した証明書を削除します。.
//
// DELETE /clusters/{clusterID}/certificates/{certificateID}
func (c *Client) DeleteCertificate(ctx context.Context, params DeleteCertificateParams) error {
	_, err := c.sendDeleteCertificate(ctx, params)
	return err
}

func (c *Client) sendDeleteCertificate(ctx context.Context, params DeleteCertificateParams) (res *DeleteCertificateNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteCertificate"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/certificates/{certificateID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteCertificateOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/certificates/"
	{
		// Encode "certificateID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "certificateID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.CertificateID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, DeleteCertificateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteCertificateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCluster invokes deleteCluster operation.
//
// 指定したクラスタを削除します。.
//
// DELETE /clusters/{clusterID}
func (c *Client) DeleteCluster(ctx context.Context, params DeleteClusterParams) error {
	_, err := c.sendDeleteCluster(ctx, params)
	return err
}

func (c *Client) sendDeleteCluster(ctx context.Context, params DeleteClusterParams) (res *DeleteClusterNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteCluster"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteClusterOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, DeleteClusterOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteLoadBalancer invokes deleteLoadBalancer operation.
//
// 指定したロードバランサーを削除します。.
//
// DELETE /clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers/{loadBalancerID}
func (c *Client) DeleteLoadBalancer(ctx context.Context, params DeleteLoadBalancerParams) error {
	_, err := c.sendDeleteLoadBalancer(ctx, params)
	return err
}

func (c *Client) sendDeleteLoadBalancer(ctx context.Context, params DeleteLoadBalancerParams) (res *DeleteLoadBalancerNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteLoadBalancer"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers/{loadBalancerID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteLoadBalancerOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/asg/"
	{
		// Encode "autoScalingGroupID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoScalingGroupID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.AutoScalingGroupID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/load_balancers/"
	{
		// Encode "loadBalancerID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "loadBalancerID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.LoadBalancerID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, DeleteLoadBalancerOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteLoadBalancerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetApplication invokes getApplication operation.
//
// 指定したアプリケーションIDの詳細情報を返します。.
//
// GET /applications/{applicationID}
func (c *Client) GetApplication(ctx context.Context, params GetApplicationParams) (*GetApplicationResponse, error) {
	res, err := c.sendGetApplication(ctx, params)
	return res, err
}

func (c *Client) sendGetApplication(ctx context.Context, params GetApplicationParams) (res *GetApplicationResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApplication"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/applications/{applicationID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetApplicationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/applications/"
	{
		// Encode "applicationID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "applicationID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ApplicationID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, GetApplicationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetApplicationContainers invokes getApplicationContainers operation.
//
// 指定したアプリケーションの各ワーカーノード上でのコンテナ配置情報を返します。.
//
// GET /applications/{applicationID}/containers
func (c *Client) GetApplicationContainers(ctx context.Context, params GetApplicationContainersParams) (*GetApplicationContainersResponse, error) {
	res, err := c.sendGetApplicationContainers(ctx, params)
	return res, err
}

func (c *Client) sendGetApplicationContainers(ctx context.Context, params GetApplicationContainersParams) (res *GetApplicationContainersResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApplicationContainers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/applications/{applicationID}/containers"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetApplicationContainersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/applications/"
	{
		// Encode "applicationID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "applicationID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ApplicationID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/containers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, GetApplicationContainersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetApplicationContainersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetApplicationVersion invokes getApplicationVersion operation.
//
// 指定されたバージョンの詳細取得.
//
// GET /applications/{applicationID}/versions/{version}
func (c *Client) GetApplicationVersion(ctx context.Context, params GetApplicationVersionParams) (*GetApplicationVersionResponse, error) {
	res, err := c.sendGetApplicationVersion(ctx, params)
	return res, err
}

func (c *Client) sendGetApplicationVersion(ctx context.Context, params GetApplicationVersionParams) (res *GetApplicationVersionResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApplicationVersion"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/applications/{applicationID}/versions/{version}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetApplicationVersionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/applications/"
	{
		// Encode "applicationID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "applicationID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ApplicationID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions/"
	{
		// Encode "version" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "version",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := int32(params.Version); true {
				return e.EncodeValue(conv.Int32ToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, GetApplicationVersionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetApplicationVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAutoScalingGroup invokes getAutoScalingGroup operation.
//
// 指定した Auto Scaling Group の詳細情報を返します。.
//
// GET /clusters/{clusterID}/asg/{autoScalingGroupID}
func (c *Client) GetAutoScalingGroup(ctx context.Context, params GetAutoScalingGroupParams) (*GetAutoScalingGroupResponse, error) {
	res, err := c.sendGetAutoScalingGroup(ctx, params)
	return res, err
}

func (c *Client) sendGetAutoScalingGroup(ctx context.Context, params GetAutoScalingGroupParams) (res *GetAutoScalingGroupResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoScalingGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/asg/{autoScalingGroupID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAutoScalingGroupOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/asg/"
	{
		// Encode "autoScalingGroupID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoScalingGroupID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.AutoScalingGroupID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, GetAutoScalingGroupOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAutoScalingGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCertificate invokes getCertificate operation.
//
// 指定した証明書の詳細情報を返します。.
//
// GET /clusters/{clusterID}/certificates/{certificateID}
func (c *Client) GetCertificate(ctx context.Context, params GetCertificateParams) (*GetCertificateResponse, error) {
	res, err := c.sendGetCertificate(ctx, params)
	return res, err
}

func (c *Client) sendGetCertificate(ctx context.Context, params GetCertificateParams) (res *GetCertificateResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCertificate"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/certificates/{certificateID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetCertificateOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/certificates/"
	{
		// Encode "certificateID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "certificateID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.CertificateID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, GetCertificateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCertificateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCluster invokes getCluster operation.
//
// 指定したクラスタの詳細情報を返します。.
//
// GET /clusters/{clusterID}
func (c *Client) GetCluster(ctx context.Context, params GetClusterParams) (*GetClusterResponse, error) {
	res, err := c.sendGetCluster(ctx, params)
	return res, err
}

func (c *Client) sendGetCluster(ctx context.Context, params GetClusterParams) (res *GetClusterResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCluster"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetClusterOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, GetClusterOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLoadBalancer invokes getLoadBalancer operation.
//
// 指定したロードバランサーの詳細情報を返します。.
//
// GET /clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers/{loadBalancerID}
func (c *Client) GetLoadBalancer(ctx context.Context, params GetLoadBalancerParams) (*GetLoadBalancerResponse, error) {
	res, err := c.sendGetLoadBalancer(ctx, params)
	return res, err
}

func (c *Client) sendGetLoadBalancer(ctx context.Context, params GetLoadBalancerParams) (res *GetLoadBalancerResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getLoadBalancer"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers/{loadBalancerID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetLoadBalancerOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/asg/"
	{
		// Encode "autoScalingGroupID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoScalingGroupID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.AutoScalingGroupID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/load_balancers/"
	{
		// Encode "loadBalancerID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "loadBalancerID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.LoadBalancerID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, GetLoadBalancerOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetLoadBalancerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLoadBalancerNode invokes getLoadBalancerNode operation.
//
// 指定したロードバランサーノードの詳細情報を返します。.
//
// GET /clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers/{loadBalancerID}/load_balancer_nodes/{loadBalancerNodeID}
func (c *Client) GetLoadBalancerNode(ctx context.Context, params GetLoadBalancerNodeParams) (*GetLoadBalancerNodeResponse, error) {
	res, err := c.sendGetLoadBalancerNode(ctx, params)
	return res, err
}

func (c *Client) sendGetLoadBalancerNode(ctx context.Context, params GetLoadBalancerNodeParams) (res *GetLoadBalancerNodeResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getLoadBalancerNode"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers/{loadBalancerID}/load_balancer_nodes/{loadBalancerNodeID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetLoadBalancerNodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/asg/"
	{
		// Encode "autoScalingGroupID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoScalingGroupID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.AutoScalingGroupID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/load_balancers/"
	{
		// Encode "loadBalancerID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "loadBalancerID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.LoadBalancerID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/load_balancer_nodes/"
	{
		// Encode "loadBalancerNodeID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "loadBalancerNodeID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.LoadBalancerNodeID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, GetLoadBalancerNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetLoadBalancerNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkerNode invokes getWorkerNode operation.
//
// 指定したワーカーノードの詳細情報を返します。.
//
// GET /clusters/{clusterID}/asg/{autoScalingGroupID}/worker_nodes/{workerNodeID}
func (c *Client) GetWorkerNode(ctx context.Context, params GetWorkerNodeParams) (*GetWorkerNodeResponse, error) {
	res, err := c.sendGetWorkerNode(ctx, params)
	return res, err
}

func (c *Client) sendGetWorkerNode(ctx context.Context, params GetWorkerNodeParams) (res *GetWorkerNodeResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getWorkerNode"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/asg/{autoScalingGroupID}/worker_nodes/{workerNodeID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetWorkerNodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/asg/"
	{
		// Encode "autoScalingGroupID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoScalingGroupID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.AutoScalingGroupID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/worker_nodes/"
	{
		// Encode "workerNodeID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workerNodeID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.WorkerNodeID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, GetWorkerNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWorkerNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListApplicationVersions invokes listApplicationVersions operation.
//
// 指定されたアプリケーションのバージョン一覧取得.
//
// GET /applications/{applicationID}/versions
func (c *Client) ListApplicationVersions(ctx context.Context, params ListApplicationVersionsParams) (*ListApplicationVersionResponse, error) {
	res, err := c.sendListApplicationVersions(ctx, params)
	return res, err
}

func (c *Client) sendListApplicationVersions(ctx context.Context, params ListApplicationVersionsParams) (res *ListApplicationVersionResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listApplicationVersions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/applications/{applicationID}/versions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListApplicationVersionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/applications/"
	{
		// Encode "applicationID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "applicationID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ApplicationID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				if unwrapped := int32(val); true {
					return e.EncodeValue(conv.Int32ToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "maxItems" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "maxItems",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Int64ToString(params.MaxItems))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, ListApplicationVersionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListApplicationVersionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListApplications invokes listApplications operation.
//
// 指定したアカウントに紐づくアプリケーションの一覧を返します。.
//
// GET /applications
func (c *Client) ListApplications(ctx context.Context, params ListApplicationsParams) (*ListApplicationResponse, error) {
	res, err := c.sendListApplications(ctx, params)
	return res, err
}

func (c *Client) sendListApplications(ctx context.Context, params ListApplicationsParams) (res *ListApplicationResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listApplications"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/applications"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListApplicationsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/applications"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "clusterID" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "clusterID",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ClusterID.Get(); ok {
				if unwrapped := uuid.UUID(val); true {
					return e.EncodeValue(conv.UUIDToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "maxItems" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "maxItems",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Int64ToString(params.MaxItems))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, ListApplicationsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListApplicationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAutoScalingGroups invokes listAutoScalingGroups operation.
//
// クラスタに所属する Auto Scaling Group
// の一覧を返します。ページネーションに対応します。.
//
// GET /clusters/{clusterID}/asg
func (c *Client) ListAutoScalingGroups(ctx context.Context, params ListAutoScalingGroupsParams) (*ListAutoScalingGroupResponse, error) {
	res, err := c.sendListAutoScalingGroups(ctx, params)
	return res, err
}

func (c *Client) sendListAutoScalingGroups(ctx context.Context, params ListAutoScalingGroupsParams) (res *ListAutoScalingGroupResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoScalingGroups"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/asg"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListAutoScalingGroupsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/asg"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "lastAutoScalingGroupID" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "lastAutoScalingGroupID",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LastAutoScalingGroupID.Get(); ok {
				if unwrapped := uuid.UUID(val); true {
					return e.EncodeValue(conv.UUIDToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				if unwrapped := uuid.UUID(val); true {
					return e.EncodeValue(conv.UUIDToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "maxItems" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "maxItems",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Int64ToString(params.MaxItems))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, ListAutoScalingGroupsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListAutoScalingGroupsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCertificate invokes listCertificate operation.
//
// クラスタ内の証明書一覧を返します。ページネーションに対応します。.
//
// GET /clusters/{clusterID}/certificates
func (c *Client) ListCertificate(ctx context.Context, params ListCertificateParams) (*ListCertificateResponse, error) {
	res, err := c.sendListCertificate(ctx, params)
	return res, err
}

func (c *Client) sendListCertificate(ctx context.Context, params ListCertificateParams) (res *ListCertificateResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCertificate"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/certificates"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListCertificateOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/certificates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "lastCertificateID" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "lastCertificateID",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LastCertificateID.Get(); ok {
				if unwrapped := uuid.UUID(val); true {
					return e.EncodeValue(conv.UUIDToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				if unwrapped := uuid.UUID(val); true {
					return e.EncodeValue(conv.UUIDToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "maxItems" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "maxItems",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Int64ToString(params.MaxItems))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, ListCertificateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListCertificateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListClusters invokes listClusters operation.
//
// アカウントに紐づくクラスタの一覧を返します。ページネーションに対応します。.
//
// GET /clusters
func (c *Client) ListClusters(ctx context.Context, params ListClustersParams) (*ListClusterResponse, error) {
	res, err := c.sendListClusters(ctx, params)
	return res, err
}

func (c *Client) sendListClusters(ctx context.Context, params ListClustersParams) (res *ListClusterResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listClusters"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/clusters"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListClustersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/clusters"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "lastClusterID" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "lastClusterID",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LastClusterID.Get(); ok {
				if unwrapped := uuid.UUID(val); true {
					return e.EncodeValue(conv.UUIDToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				if unwrapped := uuid.UUID(val); true {
					return e.EncodeValue(conv.UUIDToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "maxItems" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "maxItems",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Int64ToString(params.MaxItems))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, ListClustersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListClustersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListLbServiceClasses invokes listLbServiceClasses operation.
//
// ロードバランサ用のサービスクラス一覧を返します。.
//
// GET /service_classes/lb
func (c *Client) ListLbServiceClasses(ctx context.Context) (*ListLbServiceClassResponse, error) {
	res, err := c.sendListLbServiceClasses(ctx)
	return res, err
}

func (c *Client) sendListLbServiceClasses(ctx context.Context) (res *ListLbServiceClassResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listLbServiceClasses"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/service_classes/lb"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListLbServiceClassesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/service_classes/lb"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, ListLbServiceClassesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListLbServiceClassesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListLoadBalancerNodes invokes listLoadBalancerNodes operation.
//
// 指定したロードバランサーに属するノードの一覧を返します。.
//
// GET /clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers/{loadBalancerID}/load_balancer_nodes
func (c *Client) ListLoadBalancerNodes(ctx context.Context, params ListLoadBalancerNodesParams) (*ListLoadBalancerNodesResponse, error) {
	res, err := c.sendListLoadBalancerNodes(ctx, params)
	return res, err
}

func (c *Client) sendListLoadBalancerNodes(ctx context.Context, params ListLoadBalancerNodesParams) (res *ListLoadBalancerNodesResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listLoadBalancerNodes"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers/{loadBalancerID}/load_balancer_nodes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListLoadBalancerNodesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/asg/"
	{
		// Encode "autoScalingGroupID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoScalingGroupID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.AutoScalingGroupID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/load_balancers/"
	{
		// Encode "loadBalancerID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "loadBalancerID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.LoadBalancerID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/load_balancer_nodes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				if unwrapped := uuid.UUID(val); true {
					return e.EncodeValue(conv.UUIDToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "maxItems" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "maxItems",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Int64ToString(params.MaxItems))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, ListLoadBalancerNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListLoadBalancerNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListLoadBalancers invokes listLoadBalancers operation.
//
// Auto Scaling Group
// に属するロードバランサーの一覧を返します。ページネーションに対応します。.
//
// GET /clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers
func (c *Client) ListLoadBalancers(ctx context.Context, params ListLoadBalancersParams) (*ListLoadBalancersResponse, error) {
	res, err := c.sendListLoadBalancers(ctx, params)
	return res, err
}

func (c *Client) sendListLoadBalancers(ctx context.Context, params ListLoadBalancersParams) (res *ListLoadBalancersResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listLoadBalancers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/asg/{autoScalingGroupID}/load_balancers"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListLoadBalancersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/asg/"
	{
		// Encode "autoScalingGroupID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoScalingGroupID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.AutoScalingGroupID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/load_balancers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				if unwrapped := uuid.UUID(val); true {
					return e.EncodeValue(conv.UUIDToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "maxItems" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "maxItems",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Int64ToString(params.MaxItems))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, ListLoadBalancersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListLoadBalancersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListWorkerNodes invokes listWorkerNodes operation.
//
// Auto Scaling Group
// に所属するワーカーノードの一覧を返します。ページネーションに対応します。.
//
// GET /clusters/{clusterID}/asg/{autoScalingGroupID}/worker_nodes
func (c *Client) ListWorkerNodes(ctx context.Context, params ListWorkerNodesParams) (*ListWorkerNodesResponse, error) {
	res, err := c.sendListWorkerNodes(ctx, params)
	return res, err
}

func (c *Client) sendListWorkerNodes(ctx context.Context, params ListWorkerNodesParams) (res *ListWorkerNodesResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listWorkerNodes"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/asg/{autoScalingGroupID}/worker_nodes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListWorkerNodesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/asg/"
	{
		// Encode "autoScalingGroupID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoScalingGroupID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.AutoScalingGroupID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/worker_nodes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				if unwrapped := uuid.UUID(val); true {
					return e.EncodeValue(conv.UUIDToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "maxItems" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "maxItems",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Int64ToString(params.MaxItems))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, ListWorkerNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListWorkerNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListWorkerServiceClasses invokes listWorkerServiceClasses operation.
//
// ワーカーノード用のサービスクラス一覧を返します。.
//
// GET /service_classes/worker
func (c *Client) ListWorkerServiceClasses(ctx context.Context) (*ListWorkerServiceClassResponse, error) {
	res, err := c.sendListWorkerServiceClasses(ctx)
	return res, err
}

func (c *Client) sendListWorkerServiceClasses(ctx context.Context) (res *ListWorkerServiceClassResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listWorkerServiceClasses"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/service_classes/worker"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListWorkerServiceClassesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/service_classes/worker"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, ListWorkerServiceClassesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListWorkerServiceClassesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateApplication invokes updateApplication operation.
//
// アプリケーションのactiveVersionなどを更新します。クラスタの変更はできません。activeVersionを変更すると指定したバージョンがデプロイされます。activeVersionをnullにするとアプリケーションは非アクティブ状態になり､デプロイされなくなります。アプリケーション削除前には activeVersion を null にする必要があります｡.
//
// PUT /applications/{applicationID}
func (c *Client) UpdateApplication(ctx context.Context, request *UpdateApplication, params UpdateApplicationParams) error {
	_, err := c.sendUpdateApplication(ctx, request, params)
	return err
}

func (c *Client) sendUpdateApplication(ctx context.Context, request *UpdateApplication, params UpdateApplicationParams) (res *UpdateApplicationNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateApplication"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/applications/{applicationID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateApplicationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/applications/"
	{
		// Encode "applicationID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "applicationID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ApplicationID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateApplicationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, UpdateApplicationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCertificate invokes updateCertificate operation.
//
// 指定した証明書を更新します。.
//
// PUT /clusters/{clusterID}/certificates/{certificateID}
func (c *Client) UpdateCertificate(ctx context.Context, request *UpdateCertificate, params UpdateCertificateParams) error {
	_, err := c.sendUpdateCertificate(ctx, request, params)
	return err
}

func (c *Client) sendUpdateCertificate(ctx context.Context, request *UpdateCertificate, params UpdateCertificateParams) (res *UpdateCertificateNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateCertificate"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/certificates/{certificateID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateCertificateOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/certificates/"
	{
		// Encode "certificateID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "certificateID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.CertificateID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCertificateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, UpdateCertificateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateCertificateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCluster invokes updateCluster operation.
//
// 指定したクラスタの設定を更新します。.
//
// PUT /clusters/{clusterID}
func (c *Client) UpdateCluster(ctx context.Context, request *UpdateCluster, params UpdateClusterParams) error {
	_, err := c.sendUpdateCluster(ctx, request, params)
	return err
}

func (c *Client) sendUpdateCluster(ctx context.Context, request *UpdateCluster, params UpdateClusterParams) (res *UpdateClusterNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateCluster"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateClusterOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateClusterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, UpdateClusterOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateWorkerNodeDrainingState invokes updateWorkerNodeDrainingState operation.
//
// 指定したワーカーノードのdraining状態を更新します（draining
// を有効/無効にします）。.
//
// PUT /clusters/{clusterID}/asg/{autoScalingGroupID}/worker_nodes/{workerNodeID}/draining
func (c *Client) UpdateWorkerNodeDrainingState(ctx context.Context, request *UpdateWorkerNodeDrainingRequest, params UpdateWorkerNodeDrainingStateParams) error {
	_, err := c.sendUpdateWorkerNodeDrainingState(ctx, request, params)
	return err
}

func (c *Client) sendUpdateWorkerNodeDrainingState(ctx context.Context, request *UpdateWorkerNodeDrainingRequest, params UpdateWorkerNodeDrainingStateParams) (res *UpdateWorkerNodeDrainingStateNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateWorkerNodeDrainingState"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/clusters/{clusterID}/asg/{autoScalingGroupID}/worker_nodes/{workerNodeID}/draining"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateWorkerNodeDrainingStateOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/clusters/"
	{
		// Encode "clusterID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.ClusterID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/asg/"
	{
		// Encode "autoScalingGroupID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autoScalingGroupID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.AutoScalingGroupID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/worker_nodes/"
	{
		// Encode "workerNodeID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workerNodeID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := uuid.UUID(params.WorkerNodeID); true {
				return e.EncodeValue(conv.UUIDToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/draining"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateWorkerNodeDrainingStateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BasicAuth"
			switch err := c.securityBasicAuth(ctx, UpdateWorkerNodeDrainingStateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateWorkerNodeDrainingStateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
